<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T4BF MPX Documentation</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        .edit-link {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #2c5282;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            text-decoration: none;
            font-family: sans-serif;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        .edit-link:hover {
            background: #1a365d;
        }
        .content-source {
            font-family: sans-serif;
            font-size: 12px;
            color: #666;
            text-align: center;
            padding: 5px;
            background: #f7fafc;
            margin-bottom: 20px;
            border-radius: 3px;
        }
        .loading-content {
            text-align: center;
            padding: 50px;
            color: #666;
            font-family: sans-serif;
        }
    </style>
</head>
<body>
    <!-- Edit Link -->
    <a href="editor.html" class="edit-link">Edit Documentation</a>

    <!-- Main Content -->
    <main id="mainContent"><h1>T4BF MPX Documentation</h1><h2>Module Status</h2><table><tbody><tr><th colspan="1" rowspan="1"><p>Module</p></th><th colspan="1" rowspan="1"><p>Status</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p>R0</p></td><td colspan="1" rowspan="1"><p>Complete</p></td><td colspan="1" rowspan="1"><p>System initialization (GDT, IDT, IRQ, PIC, VM, Serial)</p></td></tr><tr><td colspan="1" rowspan="1"><p>R1</p></td><td colspan="1" rowspan="1"><p>Complete</p></td><td colspan="1" rowspan="1"><p>Command handler, polling I/O, RTC commands</p></td></tr><tr><td colspan="1" rowspan="1"><p>R2</p></td><td colspan="1" rowspan="1"><p>Pending</p></td><td colspan="1" rowspan="1"><p>Process control blocks and queues</p></td></tr><tr><td colspan="1" rowspan="1"><p>R3</p></td><td colspan="1" rowspan="1"><p>Pending</p></td><td colspan="1" rowspan="1"><p>Context switching</p></td></tr><tr><td colspan="1" rowspan="1"><p>R4</p></td><td colspan="1" rowspan="1"><p>Pending</p></td><td colspan="1" rowspan="1"><p>Process scheduling</p></td></tr><tr><td colspan="1" rowspan="1"><p>R5</p></td><td colspan="1" rowspan="1"><p>Pending</p></td><td colspan="1" rowspan="1"><p>Memory management</p></td></tr><tr><td colspan="1" rowspan="1"><p>R6</p></td><td colspan="1" rowspan="1"><p>Pending</p></td><td colspan="1" rowspan="1"><p>Interrupt-driven I/O</p></td></tr></tbody></table><h1>User's Manual</h1><h2>Introduction</h2><p>Welcome to the T4BF MPX Operating System. This manual provides comprehensive documentation for all available commands and system functionality.</p><p>MPX (Multiprogramming Executive) is a simple operating system designed for educational purposes. This documentation will guide you through all available commands and their usage.</p><h2>Getting Started</h2><p>After booting MPX, you will be presented with a command prompt. From here, you can enter any of the commands documented below.</p><h3>Basic Usage</h3><p>Type a command and press Enter to execute it. Commands are case-insensitive.</p><pre><code class="language-bash">&gt; help
&gt; version
&gt; shutdown</code></pre><h2>Command Reference</h2><h3><u>help</u></h3><p><strong>Syntax:</strong> <code>help, help [command]</code></p><p><strong>Description:</strong> Displays help information for available commands. When called without arguments, lists all commands. When called with a command name, displays detailed help for that specific command.</p><p><strong>Parameters:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Parameter</p></th><th colspan="1" rowspan="1"><p>Required</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>command</code></p></td><td colspan="1" rowspan="1"><p>No</p></td><td colspan="1" rowspan="1"><p>The name of the command to get help for</p></td></tr></tbody></table><p><strong>Examples:</strong></p><pre><code class="language-bash"># List all available commands
&gt; help

# Get help for a specific command
&gt; help shutdown</code></pre><h3><u>version</u></h3><p><strong>Syntax:</strong> <code>version</code></p><p><strong>Description:</strong> Displays the current version of MPX and compilation information.</p><p><strong>Examples:</strong></p><pre><code class="language-bash">&gt; version
&gt; MPX Version: 1.0
Compiled: January 2026</code></pre><h3><u>shutdown</u></h3><p><strong>Syntax:</strong> <code>shutdown</code></p><p><strong>Description:</strong> Safely shuts down the MPX system. Prompts for confirmation before proceeding.</p><p><strong>Examples:</strong></p><pre><code class="language-bash">&gt; shutdown
&gt; Are you sure you want to shutdown? (yes/no): yes
Shutting down...</code></pre><h3><u>getdate</u></h3><p><strong>Syntax:</strong> <code>getdate</code></p><p><strong>Description:</strong> Reads the current date from the Real-Time Clock (RTC) and displays it in MM/DD/YYYY format.</p><p><strong>Examples:</strong></p><pre><code class="language-bash">&gt; getdate
Current date: 02/04/2026</code></pre><h3><u>setdate</u></h3><p><strong>Syntax:</strong> <code>setdate MM/DD/YYYY</code></p><p><strong>Description:</strong> Sets the system date in the RTC. The date must be in MM/DD/YYYY format.</p><p><strong>Parameters:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Parameter</p></th><th colspan="1" rowspan="1"><p>Required</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>MM/DD/YYYY</code></p></td><td colspan="1" rowspan="1"><p>Yes</p></td><td colspan="1" rowspan="1"><p>Date to set. Month (1-12), Day (1-31), Year (1900-2099)</p></td></tr></tbody></table><p><strong>Examples:</strong></p><pre><code class="language-bash">&gt; setdate 01/26/2026
Date set successfully.</code></pre><h3><u>gettime</u></h3><p><strong>Syntax:</strong> <code>gettime</code></p><p><strong>Description:</strong> Reads the current time from the RTC and displays it in HH:MM:SS format (24-hour).</p><p><strong>Examples:</strong></p><pre><code class="language-bash">&gt; gettime
Current time: 14:30:45</code></pre><h3><u>settime</u></h3><p><strong>Syntax:</strong> <code>settime HH:MM:SS</code></p><p><strong>Description:</strong> Sets the system time in the RTC. Time must be in HH:MM:SS format (24-hour).</p><p><strong>Parameters:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Parameter</p></th><th colspan="1" rowspan="1"><p>Required</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>HH:MM:SS</code></p></td><td colspan="1" rowspan="1"><p>Yes</p></td><td colspan="1" rowspan="1"><p>Time to set. Hours (0-23), Minutes (0-59), Seconds (0-59)</p></td></tr></tbody></table><p><strong>Examples:</strong></p><pre><code class="language-bash">&gt; settime 14:30:00
Time set successfully.</code></pre><h2>Quick Reference</h2><table><tbody><tr><th colspan="1" rowspan="1"><p>Command</p></th><th colspan="1" rowspan="1"><p>Description</p></th><th colspan="1" rowspan="1"><p>Syntax</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>help</code></p></td><td colspan="1" rowspan="1"><p>Display help information</p></td><td colspan="1" rowspan="1"><p><code>help, help [command]</code></p></td></tr><tr><td colspan="1" rowspan="1"><p><code>version</code></p></td><td colspan="1" rowspan="1"><p>Display version information</p></td><td colspan="1" rowspan="1"><p><code>version</code></p></td></tr><tr><td colspan="1" rowspan="1"><p><code>shutdown</code></p></td><td colspan="1" rowspan="1"><p>Shutdown the system</p></td><td colspan="1" rowspan="1"><p><code>shutdown</code></p></td></tr><tr><td colspan="1" rowspan="1"><p><code>getdate</code></p></td><td colspan="1" rowspan="1"><p>Display current date</p></td><td colspan="1" rowspan="1"><p><code>getdate</code></p></td></tr><tr><td colspan="1" rowspan="1"><p><code>setdate</code></p></td><td colspan="1" rowspan="1"><p>Set the system date</p></td><td colspan="1" rowspan="1"><p><code>setdate MM/DD/YYYY</code></p></td></tr><tr><td colspan="1" rowspan="1"><p><code>gettime</code></p></td><td colspan="1" rowspan="1"><p>Display current time</p></td><td colspan="1" rowspan="1"><p><code>gettime</code></p></td></tr><tr><td colspan="1" rowspan="1"><p><code>settime</code></p></td><td colspan="1" rowspan="1"><p>Set the system time</p></td><td colspan="1" rowspan="1"><p><code>settime HH:MM:SS</code></p></td></tr></tbody></table><h1>Programmer's Manual</h1><h2>Overview</h2><p>This section documents all functions, data types, and structures available in the T4BF MPX system. Use this reference to extend and modify the system.</p><h3>Module Organization</h3><ul><li><p><strong>memory.h</strong> - Memory management functions</p></li><li><p><strong>processes.h</strong> - Process management and PCB operations</p></li><li><p><strong>string.h</strong> - String manipulation utilities</p></li><li><p><strong>stdlib.h</strong> - Standard library functions</p></li><li><p><strong>ctype.h</strong> - Character type functions</p></li><li><p><strong>sys_req.h</strong> - System request interface</p></li><li><p><strong>mpx/rtc.h</strong> - Real-Time Clock functions</p></li><li><p><strong>cmd_helpers.h</strong> - Command helper utilities</p></li></ul><h2>Data Types</h2><h3>op_code</h3><p><strong>Purpose:</strong> Enum for system request operation codes.</p><p><strong>Definition:</strong></p><p>typedef enum { EXIT, // Terminate the calling process IDLE, // Suspend the calling process READ, // Read from a device WRITE, // Write to a device } op_code;</p><p><strong>Values:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Value</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>EXIT</code></p></td><td colspan="1" rowspan="1"><p>Terminate the calling process (R3+)</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>IDLE</code></p></td><td colspan="1" rowspan="1"><p>Suspend the calling process (R3+)</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>READ</code></p></td><td colspan="1" rowspan="1"><p>Read data from a serial port</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>WRITE</code></p></td><td colspan="1" rowspan="1"><p>Write data to a serial port</p></td></tr></tbody></table><h3>device</h3><p><strong>Purpose:</strong> Device constants for serial port communication.</p><p><strong>Definition:</strong></p><pre><code class="language-c">// Defined in mpx/device.h
#define COM1 0x3F8
#define COM2 0x2F8
#define COM3 0x3E8
#define COM4 0x2E8</code></pre><h3>struct rtc_time</h3><p><strong>Purpose:</strong> Structure for storing time values from the RTC.</p><p><strong>Definition:</strong></p><pre><code class="language-c">struct rtc_time {
    int hours;    // 0-23
    int minutes;  // 0-59
    int seconds;  // 0-59
};</code></pre><h3>struct rtc_date</h3><p><strong>Purpose:</strong> Structure for storing date values from the RTC.</p><p><strong>Definition:</strong></p><pre><code class="language-c">struct rtc_date {
    int month;  // 1-12
    int day;    // 1-31
    int year;   // full year (e.g., 2026)
};</code></pre><h3>command_history</h3><p><strong>Purpose:</strong> Structure for storing command history (for future up/down arrow support).</p><p><strong>Definition:</strong></p><pre><code class="language-c">typedef struct {
    char entries[HISTORY_SIZE][MAX_CMD_LENGTH];
    int count;      // how many saved so far
    int current;    // position while scrolling
    int head;       // points to newest entry
} command_history;</code></pre><p><strong>Note:</strong> Defined in mpx/serial.h but not yet implemented. Will support up/down arrow history navigation in future releases.</p><h2>Function Reference</h2><h3>serial_init</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">int serial_init(device dev);</code></pre><p><strong>Description:</strong> Initializes a serial port for communication. Sets baud rate to 9600, 8 data bits, no parity, 1 stop bit.</p><p><strong>Parameters:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Parameter</p></th><th colspan="1" rowspan="1"><p>Type</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>dev</code></p></td><td colspan="1" rowspan="1"><p><code>device</code></p></td><td colspan="1" rowspan="1"><p>Serial port to initialize (COM1, COM2, etc.)</p></td></tr></tbody></table><p><strong>Return Value:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Value</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>0</code></p></td><td colspan="1" rowspan="1"><p>Success</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>-1</code></p></td><td colspan="1" rowspan="1"><p>Invalid device</p></td></tr></tbody></table><h3>serial_out</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">int serial_out(device dev, const char *buffer, size_t len);</code></pre><p><strong>Description:</strong> Writes data to a serial port.</p><p><strong>Parameters:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Parameter</p></th><th colspan="1" rowspan="1"><p>Type</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>dev</code></p></td><td colspan="1" rowspan="1"><p><code>device</code></p></td><td colspan="1" rowspan="1"><p>Serial port to write to</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>buffer</code></p></td><td colspan="1" rowspan="1"><p><code>const char*</code></p></td><td colspan="1" rowspan="1"><p>Data to write</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>len</code></p></td><td colspan="1" rowspan="1"><p><code>size_t</code></p></td><td colspan="1" rowspan="1"><p>Number of bytes to write</p></td></tr></tbody></table><p><strong>Return Value:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Value</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>len</code></p></td><td colspan="1" rowspan="1"><p>Number of bytes written on success</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>-1</code></p></td><td colspan="1" rowspan="1"><p>Invalid device or not initialized</p></td></tr></tbody></table><h3>serial_poll</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">int serial_poll(device dev, char *buffer, size_t len);</code></pre><p><strong>Description:</strong> Polls the serial port for input with full line editing support. Reads characters until Enter is pressed or buffer is full. Supports backspace, left/right arrow keys for cursor movement, Home/End keys to jump to line start/end, Delete key to remove character at cursor, and insert mode for typing in the middle of a line.</p><p><strong>Parameters:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Parameter</p></th><th colspan="1" rowspan="1"><p>Type</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>dev</code></p></td><td colspan="1" rowspan="1"><p><code>device</code></p></td><td colspan="1" rowspan="1"><p>Serial port to read from</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>buffer</code></p></td><td colspan="1" rowspan="1"><p><code>char*</code></p></td><td colspan="1" rowspan="1"><p>Buffer to store input</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>len</code></p></td><td colspan="1" rowspan="1"><p><code>size_t</code></p></td><td colspan="1" rowspan="1"><p>Size of the buffer</p></td></tr></tbody></table><p><strong>Return Value:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Value</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>&gt;= 0</code></p></td><td colspan="1" rowspan="1"><p>Number of bytes read</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>-1</code></p></td><td colspan="1" rowspan="1"><p>Invalid buffer or length</p></td></tr></tbody></table><h3>sys_req</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">int sys_req(op_code op, ...);</code></pre><p><strong>Description:</strong> System request function. The main interface between user space and kernel. For READ/WRITE, additional parameters are required.</p><p><strong>Parameters (READ/WRITE):</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Parameter</p></th><th colspan="1" rowspan="1"><p>Type</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>op</code></p></td><td colspan="1" rowspan="1"><p><code>op_code</code></p></td><td colspan="1" rowspan="1"><p>Operation: READ or WRITE</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>dev</code></p></td><td colspan="1" rowspan="1"><p><code>device</code></p></td><td colspan="1" rowspan="1"><p>Device to read from or write to</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>buf</code></p></td><td colspan="1" rowspan="1"><p><code>char*</code></p></td><td colspan="1" rowspan="1"><p>Buffer for data</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>len</code></p></td><td colspan="1" rowspan="1"><p><code>size_t</code></p></td><td colspan="1" rowspan="1"><p>Buffer size / bytes to write</p></td></tr></tbody></table><p><strong>Return Value:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Value</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>&gt;= 0</code></p></td><td colspan="1" rowspan="1"><p>Number of bytes read/written</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>-1</code></p></td><td colspan="1" rowspan="1"><p>Invalid operation</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>-2</code></p></td><td colspan="1" rowspan="1"><p>Invalid buffer</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>-3</code></p></td><td colspan="1" rowspan="1"><p>Invalid count</p></td></tr></tbody></table><p><strong>Example:</strong></p><pre><code class="language-c">char buf[128];
// Read user input
int n = sys_req(READ, COM1, buf, sizeof(buf));

// Write output
sys_req(WRITE, COM1, "Hello\r\n", 7);</code></pre><h3>sys_alloc_mem</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">void *sys_alloc_mem(size_t size);</code></pre><p><strong>Description:</strong> Allocates dynamic memory. This is the MPX equivalent of malloc().</p><p><strong>Parameters:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Parameter</p></th><th colspan="1" rowspan="1"><p>Type</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>size</code></p></td><td colspan="1" rowspan="1"><p><code>size_t</code></p></td><td colspan="1" rowspan="1"><p>Number of bytes to allocate</p></td></tr></tbody></table><p><strong>Return Value:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Value</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>void*</code></p></td><td colspan="1" rowspan="1"><p>Pointer to allocated memory</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>NULL</code></p></td><td colspan="1" rowspan="1"><p>Allocation failed</p></td></tr></tbody></table><h3>sys_free_mem</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">int sys_free_mem(void *ptr);</code></pre><p><strong>Description:</strong> Frees memory allocated by sys_alloc_mem().</p><p><strong>Parameters:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Parameter</p></th><th colspan="1" rowspan="1"><p>Type</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>ptr</code></p></td><td colspan="1" rowspan="1"><p><code>void*</code></p></td><td colspan="1" rowspan="1"><p>Pointer to memory to free</p></td></tr></tbody></table><p><strong>Return Value:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Value</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>0</code></p></td><td colspan="1" rowspan="1"><p>Success</p></td></tr><tr><td colspan="1" rowspan="1"><p><code>non-zero</code></p></td><td colspan="1" rowspan="1"><p>Error</p></td></tr></tbody></table><h3>rtc_get_time</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">void rtc_get_time(struct rtc_time *time);</code></pre><p><strong>Description:</strong> Reads the current time from the RTC hardware into the provided structure.</p><p><strong>Parameters:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Parameter</p></th><th colspan="1" rowspan="1"><p>Type</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>time</code></p></td><td colspan="1" rowspan="1"><p><code>struct rtc_time*</code></p></td><td colspan="1" rowspan="1"><p>Pointer to structure to fill with hours, minutes, seconds</p></td></tr></tbody></table><h3>rtc_set_time</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">void rtc_set_time(const struct rtc_time *time);</code></pre><p><strong>Description:</strong> Sets the RTC hardware time from the provided structure.</p><p><strong>Parameters:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Parameter</p></th><th colspan="1" rowspan="1"><p>Type</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>time</code></p></td><td colspan="1" rowspan="1"><p><code>const struct rtc_time*</code></p></td><td colspan="1" rowspan="1"><p>Pointer to structure with hours, minutes, seconds to set</p></td></tr></tbody></table><h3>rtc_get_date</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">void rtc_get_date(struct rtc_date *date);</code></pre><p><strong>Description:</strong> Reads the current date from the RTC hardware into the provided structure.</p><p><strong>Parameters:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Parameter</p></th><th colspan="1" rowspan="1"><p>Type</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>date</code></p></td><td colspan="1" rowspan="1"><p><code>struct rtc_date*</code></p></td><td colspan="1" rowspan="1"><p>Pointer to structure to fill with month, day, year</p></td></tr></tbody></table><h3>rtc_set_date</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">void rtc_set_date(const struct rtc_date *date);</code></pre><p><strong>Description:</strong> Sets the RTC hardware date from the provided structure.</p><p><strong>Parameters:</strong></p><table><tbody><tr><th colspan="1" rowspan="1"><p>Parameter</p></th><th colspan="1" rowspan="1"><p>Type</p></th><th colspan="1" rowspan="1"><p>Description</p></th></tr><tr><td colspan="1" rowspan="1"><p><code>date</code></p></td><td colspan="1" rowspan="1"><p><code>const struct rtc_date*</code></p></td><td colspan="1" rowspan="1"><p>Pointer to structure with month, day, year to set</p></td></tr></tbody></table><h3>print</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">void print(const char *str);</code></pre><p><strong>Description:</strong> Helper function to output a string to COM1. Wrapper around sys_req(WRITE, ...).</p><h3>int_to_str</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">void int_to_str(int num, char *buf);</code></pre><p><strong>Description:</strong> Converts an integer to its string representation. Handles negative numbers and zero.</p><h3>bcd_to_bin</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">int bcd_to_bin(unsigned char bcd);</code></pre><p><strong>Description:</strong> Converts a BCD (Binary-Coded Decimal) value to binary. Used when reading from RTC registers.</p><h3>bin_to_bcd</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">unsigned char bin_to_bcd(int bin);</code></pre><p><strong>Description:</strong> Converts a binary value to BCD format. Used when writing to RTC registers.</p><h3>comhand</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">void comhand(void);</code></pre><p><strong>Description:</strong> Main command handler (shell). Implements a REPL loop that reads user input, parses commands, and dispatches to the appropriate handler. This is the user interface to MPX.</p><p><strong>Supported Commands:</strong> help, version, shutdown, getdate, setdate, gettime, settime</p><h3>strlen</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">size_t strlen(const char *s);</code></pre><p><strong>Description:</strong> Returns the length of the string (not including null terminator).</p><h3>strcmp</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">int strcmp(const char *s1, const char *s2);</code></pre><p><strong>Description:</strong> Compares two strings lexicographically. Returns 0 if equal, negative if s1 &lt; s2, positive if s1 &gt; s2.</p><h3>memmove</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">void *memmove(void *dest, const void *src, size_t n);</code></pre><p><strong>Description:</strong> Copies n bytes from src to dest. Unlike memcpy, handles overlapping memory regions correctly.</p><h3>strtok</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">char *strtok(char *s1, const char *s2);</code></pre><p><strong>Description:</strong> Tokenizes a string. First call passes the string to tokenize; subsequent calls pass NULL to continue tokenizing. Returns NULL when no more tokens.</p><h3>atoi</h3><p><strong>Prototype:</strong></p><pre><code class="language-c">int atoi(const char *str);</code></pre><p><strong>Description:</strong> Converts a string to an integer. Handles leading whitespace and optional sign.</p><h2>Modules</h2><h3>mpx/serial.h</h3><p>Serial port communication functions.</p><ul><li><p><code>serial_init()</code> - Initialize a serial port</p></li><li><p><code>serial_out()</code> - Write to serial port</p></li><li><p><code>serial_poll()</code> - Poll for serial input with line editing</p></li></ul><h3>mpx/rtc.h</h3><p>Real-Time Clock hardware access.</p><ul><li><p><code>rtc_get_time()</code> - Read current time</p></li><li><p><code>rtc_set_time()</code> - Set current time</p></li><li><p><code>rtc_get_date()</code> - Read current date</p></li><li><p><code>rtc_set_date()</code> - Set current date</p></li></ul><h3>cmd_helpers.h</h3><p>Shared utility functions for commands.</p><ul><li><p><code>print()</code> - Output string to COM1</p></li><li><p><code>int_to_str()</code> - Convert integer to string</p></li><li><p><code>bcd_to_bin()</code> - Convert BCD to binary</p></li><li><p><code>bin_to_bcd()</code> - Convert binary to BCD</p></li></ul><h3>sys_req.h</h3><p>User-to-kernel interface.</p><ul><li><p><code>sys_req()</code> - System request (READ/WRITE)</p></li></ul><h3>memory.h</h3><p>Dynamic memory allocation.</p><ul><li><p><code>sys_alloc_mem()</code> - Allocate memory</p></li><li><p><code>sys_free_mem()</code> - Free memory</p></li></ul><h3>string.h</h3><p>String functions (limited standard library).</p><ul><li><p><code>strlen()</code> - Get string length</p></li><li><p><code>strcmp()</code> - Compare strings</p></li><li><p><code>memcpy()</code> - Copy memory</p></li><li><p><code>memset()</code> - Fill memory</p></li><li><p><code>memmove()</code> - Copy memory (handles overlapping regions)</p></li><li><p><code>strtok()</code> - Tokenize string</p></li></ul><h3>stdlib.h</h3><p>Standard library functions.</p><ul><li><p><code>atoi()</code> - String to integer</p></li></ul><h3>mpx/io.h</h3><p>Low-level I/O macros.</p><ul><li><p><code>inb()</code> - Read byte from I/O port</p></li><li><p><code>outb()</code> - Write byte to I/O port</p></li></ul><h3>comhand.h</h3><p>Command handler (shell) interface.</p><ul><li><p><code>comhand()</code> - Main REPL loop</p></li></ul><h2>Project Structure</h2><pre><code>T4BF/
├── kernel/          # Kernel code
│   ├── kmain.c      # Kernel entry point
│   ├── serial.c     # Serial port driver
│   ├── rtc.c        # Real-time clock driver
│   ├── core-c.c     # GDT/IDT/IRQ/PIC/VM (provided)
│   └── core-asm.s   # Assembly routines (provided)
├── user/            # User space code
│   ├── comhand.c    # Command handler
│   ├── cmd_help.c   # help command
│   ├── cmd_version.c# version command
│   ├── cmd_shutdown.c# shutdown command
│   ├── cmd_getdate.c# getdate command
│   ├── cmd_setdate.c# setdate command
│   ├── cmd_gettime.c# gettime command
│   ├── cmd_settime.c# settime command
│   ├── cmd_helpers.c# Shared helper functions
│   └── core.c       # sys_req implementation (provided)
├── lib/             # Library functions
│   ├── string.c     # String functions
│   ├── stdlib.c     # Standard library
│   ├── ctype.c      # Character types
│   └── core.c       # Memory allocation (provided)
└── include/         # Header files
    ├── mpx/         # Kernel headers
    └── *.h          # User/lib headers</code></pre></main>

    <!--prism.js for syntax highlighting (we can change this later if needed)-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>

    <!-- Firebase SDK for loading dynamic content -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="firebase-config.js"></script>

    <!-- Load content from Firebase with static fallback -->
    <script>
        (function() {
            const mainContent = document.getElementById('mainContent');

            function escapeHtml(s) {
                const div = document.createElement('div');
                div.textContent = s;
                return div.innerHTML;
            }

            function resolveDisplayName(email, assignment, usersMap) {
                if (!email) return 'Unknown';
                const fromUser = usersMap && usersMap[email] && usersMap[email].name;
                if (fromUser && String(fromUser).trim()) return String(fromUser).trim();
                if (assignment && assignment.displayName) return assignment.displayName;
                return email.split('@')[0];
            }

            function injectContributions() {
                const db = typeof firebase !== 'undefined' && firebase.apps.length ? firebase.database() : null;
                const defPromise = db
                    ? db.ref('contributions/definition').once('value').then(function(snap) {
                        const val = snap.val();
                        if (val && val.releases && val.releases.length) return val;
                        return fetch('data/contributions.json').then(function(r) { return r.ok ? r.json() : null; }).catch(function() { return null; });
                    }).catch(function() { return fetch('data/contributions.json').then(function(r) { return r.ok ? r.json() : null; }).catch(function() { return null; }); })
                    : fetch('data/contributions.json').then(function(r) { return r.ok ? r.json() : null; }).catch(function() { return null; });
                const assignPromise = db ? db.ref('contributions/assignments').once('value').then(function(snap) { return snap.val() || {}; }) : Promise.resolve({});
                const usersPromise = db ? db.ref('users').once('value').then(function(snap) {
                    const val = snap.val();
                    const map = {};
                    if (val) {
                        Object.keys(val).forEach(function(k) {
                            const u = val[k];
                            const email = u.email || k.replace(/,/g, '.');
                            map[email] = { name: u.name || '' };
                        });
                    }
                    return map;
                }).catch(function() { return {}; }) : Promise.resolve({});
                Promise.all([ defPromise, assignPromise, usersPromise ]).then(function(results) {
                    const contributionsData = results[0];
                    const assignments = results[1];
                    const usersMap = results[2];
                    if (!contributionsData || !contributionsData.releases || Object.keys(assignments).length === 0) {
                        const block = document.getElementById('contributionsBlock');
                        if (block) block.innerHTML = '';
                        return;
                    }

                    const byMember = {};
                    Object.keys(assignments).forEach(function(id) {
                        const a = assignments[id];
                        const email = a && (a.email || a);
                        const name = resolveDisplayName(email, a, usersMap);
                        if (!email) return;
                        if (!byMember[email]) byMember[email] = { name: name, ids: [] };
                        byMember[email].ids.push(id);
                    });

                    let html = '<h1>Contributions</h1><h2>Overview</h2><p>This section documents each team member\'s contributions to the T4BF MPX project throughout the semester.</p>';
                    contributionsData.releases.forEach(function(release) {
                        html += '<h2>' + escapeHtml(release.title) + '</h2><table><tbody><tr><th><p>Task</p></th><th><p>Description</p></th><th><p>Files</p></th></tr>';
                        (release.rows || []).forEach(function(row, idx) {
                            const id = release.id + '-' + idx;
                            html += '<tr><td><p>' + escapeHtml(row.task) + '</p></td><td><p>' + escapeHtml(row.description) + '</p></td><td><p>' + escapeHtml(row.files) + '</p></td></tr>';
                        });
                        html += '</tbody></table>';
                    });
                    html += '<h2>Team Members</h2>';
                    Object.keys(byMember).sort().forEach(function(email) {
                        const m = byMember[email];
                        html += '<h3>' + escapeHtml(m.name) + '</h3><h4>Functions Implemented</h4><table><tbody><tr><th><p>Function</p></th><th><p>Module</p></th><th><p>Description</p></th></tr>';
                        m.ids.forEach(function(cid) {
                            const parts = cid.split('-');
                            const releaseId = parts[0];
                            const rowIdx = parseInt(parts[1], 10);
                            const release = contributionsData.releases.find(function(r) { return r.id === releaseId; });
                            if (!release || !release.rows || !release.rows[rowIdx]) return;
                            const row = release.rows[rowIdx];
                            html += '<tr><td><p><code>' + escapeHtml(row.task) + '</code></p></td><td><p>' + escapeHtml(row.files) + '</p></td><td><p>' + escapeHtml(row.description) + '</p></td></tr>';
                        });
                        html += '</tbody></table>';
                    });

                    let block = document.getElementById('contributionsBlock');
                    if (!block) {
                        block = document.createElement('div');
                        block.id = 'contributionsBlock';
                        mainContent.appendChild(block);
                    }
                    block.innerHTML = html;
                    if (typeof Prism !== 'undefined') Prism.highlightAll();
                }).catch(function(err) { console.log('Contributions injection error:', err.message); });
            }

            function setupContributionsListeners() {
                const db = typeof firebase !== 'undefined' && firebase.apps.length ? firebase.database() : null;
                if (!db) return;
                db.ref('contributions/definition').on('value', function() { injectContributions(); });
                db.ref('contributions/assignments').on('value', function() { injectContributions(); });
            }

            function loadFromFirebase() {
                let p = Promise.resolve();
                try {
                    if (typeof firebase === 'undefined' || typeof firebaseConfig === 'undefined') {
                        console.log('Firebase not configured, using static content');
                    } else {
                        if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
                        setupContributionsListeners();
                        p = firebase.database().ref('documentation/htmlCache').once('value')
                            .then(function(snapshot) {
                                if (snapshot.exists()) {
                                    const data = snapshot.val();
                                    if (data.content) {
                                        mainContent.innerHTML = data.content;
                                        if (typeof Prism !== 'undefined') Prism.highlightAll();
                                        console.log('Content loaded from Firebase');
                                    }
                                } else {
                                    console.log('No Firebase content, using static');
                                }
                            })
                            .catch(function(error) {
                                console.log('Firebase load error, using static:', error.message);
                            });
                    }
                } catch (error) {
                    console.log('Firebase initialization error:', error.message);
                }
                p.then(injectContributions);
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', loadFromFirebase);
            } else {
                loadFromFirebase();
            }
        })();
    </script>

    <!-- smooth scrolling and active nav highlighting -->
    <script>
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth' });
                }
            });
        });
    </script>
</body>
</html>

